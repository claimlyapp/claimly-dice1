<!DOCTYPE html>
<html>
<head>
    <title>Claimly Dice - 3D Casino</title>
    <script src="https://unpkg.com/three@0.158.0/build/three.min.js"></script>
    <script src="https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js"></script>
    <style>
        body { margin: 0; background: radial-gradient(circle, #1a0033, #000); 
               color: white; font-family: 'Arial Black', sans-serif; overflow: hidden; }
        #ui { position: absolute; top: 20px; left: 20px; z-index: 100; }
        #balance { font-size: 24px; color: #ffd700; margin: 10px 0; }
        #bet-input, #multiplier { padding: 12px; font-size: 18px; 
                                 border: 2px solid #ffd700; background: rgba(0,0,0,0.8); 
                                 color: white; border-radius: 8px; width: 120px; }
        button { padding: 15px 30px; font-size: 20px; background: linear-gradient(45deg, #ff6b35, #f7931e);
                border: none; color: white; border-radius: 25px; cursor: pointer; 
                margin: 10px; font-weight: bold; transition: all 0.3s; }
        button:hover { transform: scale(1.05); box-shadow: 0 10px 30px rgba(255,107,53,0.5); }
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        #result { font-size: 28px; font-weight: bold; text-align: center; margin: 20px 0; 
                 min-height: 40px; color: #00ff88; }
        #canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100vh; }
    </style>
</head>
<body>
    <div id="ui">
        <div id="balance">$1,000.00</div>
        <input type="number" id="bet-input" value="25" min="1" max="1000">
        <select id="multiplier">
            <option value="2">2x</option>
            <option value="3">3x</option>
            <option value="5">5x</option>
            <option value="10">10x</option>
        </select>
        <br>
        <button id="roll-btn" onclick="rollDice()">ðŸŽ² ROLL DICE</button>
        <button id="cashout-btn" onclick="cashout()" disabled>CASHOUT</button>
        <div id="result"></div>
    </div>
    <canvas id="canvas"></canvas>

    <script>
        // 3D Scene Setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.getElementById('canvas') });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Physics World
        const world = new CANNON.World();
        world.gravity.set(0, -9.82, 0);
        world.broadphase = new CANNON.NaiveBroadphase();

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        scene.add(directionalLight);

        // Table/Floor
        const tableGeometry = new THREE.PlaneGeometry(20, 20);
        const tableMaterial = new THREE.MeshLambertMaterial({ color: 0x2d5016 });
        const table = new THREE.Mesh(tableGeometry, tableMaterial);
        table.rotation.x = -Math.PI / 2;
        table.receiveShadow = true;
        scene.add(table);

        const tableBody = new CANNON.Body({ mass: 0 });
        tableBody.addShape(new CANNON.Plane());
        tableBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
        world.addBody(tableBody);

        // Dice
        let diceMesh, diceBody;
        let rollResult = 0;
        let isRolling = false;
        let balance = 1000;
        let betAmount = 25;
        let multiplier = 2;
        let potentialWin = 50;

        function createDice() {
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const materials = [
                new THREE.MeshLambertMaterial({ color: 0xffffff }), // 1
                new THREE.MeshLambertMaterial({ color: 0xffffff }), // 2  
                new THREE.MeshLambertMaterial({ color: 0xffffff }), // 3
                new THREE.MeshLambertMaterial({ color: 0xffffff }), // 4
                new THREE.MeshLambertMaterial({ color: 0xffffff }), // 5
                new THREE.MeshLambertMaterial({ color: 0xffffff })  // 6
            ];
            
            diceMesh = new THREE.Mesh(geometry, materials);
            diceMesh.castShadow = true;
            diceMesh.receiveShadow = true;
            scene.add(diceMesh);

            diceBody = new CANNON.Body({ mass: 1 });
            diceBody.addShape(new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)));
            diceBody.material = new CANNON.Material({ friction: 0.3, restitution: 0.7 });
            world.addBody(diceBody);
        }

        // API Integration (your Vercel backend)
        const API_BASE = 'https://claimly-dice-server-[YOUR-URL].vercel.app/api';

        async function rollDice() {
            if (isRolling || balance < betAmount) return;
            
            isRolling = true;
            document.getElementById('roll-btn').disabled = true;
            
            // Real server roll (provably fair)
            try {
                const token = localStorage.getItem('authToken') || await registerTestUser();
                const response = await fetch(`${API_BASE}/dice/roll`, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ 
                        betAmount, 
                        multiplier,
                        clientSeed: Math.random().toString()
                    })
                });
                const result = await response.json();
                
                rollResult = result.rollResult;
                balance = result.newBalance;
                updateUI();
                
                // Animate dice to match server result
                animateRollToResult(result.rollResult);
                
            } catch (error) {
                console.error('Roll failed:', error);
                isRolling = false;
                document.getElementById('roll-btn').disabled = false;
            }
        }

        function animateRollToResult(targetResult) {
            // Throw dice high with random spin
            diceBody.position.set(Math.random() * 4 - 2, 8, Math.random() * 4 - 2);
            diceBody.velocity.set((Math.random() - 0.5) * 10, 0, (Math.random() - 0.5) * 10);
            diceBody.angularVelocity.set(
                (Math.random() - 0.5) * 50,
                (Math.random() - 0.5) * 50,
                (Math.random() - 0.5) * 50
            );

            // Check result after settling
            const checkInterval = setInterval(() => {
                if (diceBody.velocity.length() < 0.1 && 
                    Math.abs(diceBody.angularVelocity.x) < 0.1 &&
                    Math.abs(diceBody.angularVelocity.y) < 0.1 &&
                    Math.abs(diceBody.angularVelocity.z) < 0.1) {
                    
                    clearInterval(checkInterval);
                    showRollResult(targetResult);
                }
            }, 100);
        }

        function showRollResult(result) {
            // Rotate dice to show correct face up
            const rotations = {
                1: { x: 0, y: 0, z: 0 },
                2: { x: Math.PI/2, y: 0, z: 0 },
                3: { x: 0, y: 0, z: Math.PI/2 },
                4: { x: Math.PI, y: 0, z: 0 },
                5: { x: 0, y: Math.PI, z: 0 },
                6: { x: 0, y: 0, z: Math.PI }
            };
            
            diceMesh.rotation.x = rotations[result].x;
            diceMesh.rotation.y = rotations[result].y;
            diceMesh.rotation.z = rotations[result].z;
            
            isRolling = false;
            document.getElementById('roll-btn').disabled = false;
        }

        // Update UI
        function updateUI() {
            document.getElementById('balance').textContent = `$${balance.toFixed(2)}`;
            potentialWin = betAmount * multiplier;
        }

        // Test user registration
        async function registerTestUser() {
            const response = await fetch(`${API_BASE}/auth/register`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    username: 'player' + Date.now(),
                    email: `player${Date.now()}@test.com`
                })
            });
            const data = await response.json();
            localStorage.setItem('authToken', data.token);
            return data.token;
        }

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);
            
            world.fixedStep();
            if (diceMesh && diceBody) {
                diceMesh.position.copy(diceBody.position);
                diceMesh.quaternion.copy(diceBody.quaternion);
            }
            
            renderer.render(scene, camera);
        }

        // Event Listeners
        document.getElementById('bet-input').addEventListener('input', (e) => {
            betAmount = parseInt(e.target.value) || 25;
            updateUI();
        });

        // Initialize
        createDice();
        camera.position.set(0, 5, 10);
        camera.lookAt(0, 0, 0);
        updateUI();
        animate();

        // Responsive
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
